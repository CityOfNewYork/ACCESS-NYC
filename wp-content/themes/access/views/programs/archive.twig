{% extends "base.twig" %}

{% block content %}
<main class="bg-color-white pb-4" id="content">
  <header class="usa-grid py-4 my-1">
    <h1 class="text-color-blue-dark">{% if category | length %}{{__('Programs', 'accessnyctheme')}}: {{ category.name }}{% else %}{{__('Programs', 'accessnyctheme')}}{% endif %}</h1>
  </header>

  <div class="usa-grid screen-desktop:layout--sidebar-small-gutter" data-js="programs" data-js-page="{{ pagination.current }}">
    <aside>
      <h2 class="type-h4">{{__('Filter Programs', 'accessnyctheme')}}:</h2>
      <c-filter-multi v-bind:terms="terms" v-on:fetch="click($event)" v-on:reset="click($event)"></c-filter-multi>
    </aside>

    <div>
      <div class="layout--gutter p-3 bg-color-grey-lightest mb-3" v-if="!init">
        {% if page.term_id | length %}
          {% include 'partials/post-teaser.twig' with {'cat': page.name} %}
        {% else %}
          {% include 'partials/post-teaser.twig' %}
        {% endif %}
      </div>

      <div class="layout--gutter p-3 bg-color-grey-lightest mb-3" v-if="page" v-for="page in posts" v-if="page.show">
        <c-card v-for="post in page.posts" :key="post.id" v-bind="post" taxonomy="programs" v-if="page.show"></c-card>

        <div v-if="!page.posts.length && page.show">
          Loading...
          {% include 'partials/spinner.twig' %}
        </div>
        <div v-else="page.show">
          <a class="btn btn-secondary btn-small screen-tablet:btn-normal btn-next mb-1 screen-mobile:mb-0" href="{{ pagination.next.link }}" v-on:click="paginate" data-amount="1" v-if="next">{{__('Next', 'accessnyctheme')}}</a>
        </div>
      </div>
    </div>
  </div>

  {# <footer class="content-footer usa-width-one-whole"> #}
    {# {% include 'partials/was-this-page-helpful.twig' %} #}
  {# </footer> #}
</main>
{% endblock %}

{% block scripts_footer %}

{% include 'partials/strings.twig' with {'strings': [
    {
      'label': 'Learn more',
      'slug': 'LEARN_MORE'
    },
    {
      'label': 'Apply',
      'slug': 'APPLY'
    },
    {
      'label': 'All',
      'slug': 'ALL'
    }
  ], 'translation_id': 'accessnyctheme'} only %}

{{ function('enqueue_script', 'assets/js/main', true) }}

<script src="https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
<script>
  Object.isEqual = _.isEqual;

  Vue.component('c-filter', {
    delimiters: ['v{', '}'],
    props: {
      'name': {type: String},
      'slug': {type: String},
      'filters': {type: Array},
      'busy': {type: Boolean},
      'STRINGS': {
        type: Object,
        default: () => ({
          'ALL': 'All'
        })
      }
    },
    data: function() {
      return {
        active: this.name
      };
    },
    methods: {
      fetch: function(event) {
        Vue.set(this, 'active', event.data.name);
        this.$emit('fetch', event);
        return this;
      },
      reset: function(event) {
        this.$emit('reset', {
          event: event,
          data: this
        });
        return this;
      }
    },
    template:
      `<div class="c-filter" data-js="filter">
        <a v-bind:href="'#' + slug" class="c-filter__header" data-js="filter" v-html="active">
          v{ active }
        </a>
        <ul v-bind:id="slug" class="c-filter__list">
          <li>
            <a class="c-filter__item" v-html="[STRINGS.ALL, name].join(' ')" v-on:click="reset">
              v{ [STRINGS.ALL, name].join(' ') }
            </a>
          </li>
          <li v-for="f in filters" v-bind:key="f.id" v-once>
            <a class="c-filter__item" v-bind:href="'#' + f.slug" v-on:click="fetch({'event': $event, 'data': f})" v-html="f.name">
              v{ f.name }
            </a>
          </li>
        </ul>
      </div>`
  });

  Vue.component('c-filter-multi', {
    delimiters: ['v{', '}'],
    props: {
      'terms': {type: Array},
      'busy': {type: Boolean},
      'STRINGS': {
        type: Object,
        default: () => ({
          'ALL': 'All'
        })
      }
    },
    methods: {
      fetch: function(event) {
        Vue.set(event.data, 'checked', !event.data.checked);
        this.$emit('fetch', event);
        return this;
      },
      reset: function(event) {
        this.$emit('reset', {
          event: event,
          data: this
        });
        return this;
      }
    },
    template:
      `<div class="c-filter-multi active">
        <ul class="c-filter-multi__list">
          <li class="c-filter-multi__item" v-for="t in terms" :key="t.term_id">
            <div class="c-filter-multi__item-header">
              <label class="checkbox">
                <input data-toggles="#" type="checkbox" :checked="t.checked" v-on:change="fetch({'event': $event, 'data': {'parent': t.slug}})" />
                <span class="checkbox__label">v{ t.name }</span>
              </label>
              <a class="c-filter-multi__item-header-toggle active" data-js="filter" v-bind:href="'#' + t.slug">
                <span class="c-filter-multi__item-header-expand">Expand category</span>
                <span class="c-filter-multi__item-header-collapse">Collapse category</span>
              </a>
            </div>
            <div aria-hidden="false" class="c-filter-multi__item-group active" v-bind:id="t.slug">
              <ul class="c-filter-multi__item-group-list">
                <li class="c-filter-multi__item-group-subitem" v-for="f in t.filters">
                  <label class="checkbox">
                    <input type="checkbox" :value="f.slug" :checked="f.checked" v-on:change="fetch({'event': $event, 'data': f})" />
                    <span class="checkbox__label text-font-size-small font-normal" v-html="f.name">v{ f.name }</span>
                  </label>
                </li>
              </ul>
            </div>
          </li>
        </ul>
      </div>`
  });

  Vue.component('c-card', {
    delimiters: ['v{', '}'],
    props: {
      'cta': {type: String},
      'title': {type: String},
      'link': {type: String},
      'subtitle': {type: String},
      'summary': {type: String},
      'category': {type: Object},
      'blank': {type: Boolean},
      'STRINGS': {
        type: Object,
        default: () => ({
          'LEARN_MORE': 'Learn more',
          'CTA': 'Apply'
        })
      }
    },
    template:
      `<article class="c-card">
        <div class="c-card__icon">
          <svg v-bind:class="'icon icon-' + category.slug" role="img">
            <title v-bind:id="'#icon-card-' + category.slug + '_title'" v-html="category.name"></title>
            <use v-bind:xlink:href="'#icon-card-' + category.slug" xmlns:xlink="http://www.w3.org/1999/xlink"></use>
          </svg>
        </div>
        <div class="c-card__body">
          <a class="text-color-blue-dark" v-bind:href="link" v-bind:target="blank ? '_blank' : false">
            <h3 class="c-card__title text-color-blue-dark">v{ title }</h3>
          </a>
          <p class="c-card__subtitle type-small" v-if="subtitle" v-html="subtitle">
            v{ subtitle }
          </p>
          <div class="c-card__summary">
            <p v-if="summary" v-html="summary">v{ summary }</p>
            <p class="hide-for-print">
              <a v-bind:href="link">v{ STRINGS.LEARN_MORE } <span class="sr-only">: v{ subtitle }</span></a>
            </p>
            <p class="hide-for-print" v-if="cta">
              <a class="btn btn-secondary btn-next" v-bind:href="cta">v{ STRINGS.CTA }</a>
            </p>
          </div>
        </div>
      </article>`
  });

  var app = new Vue({
    el: '[data-js="programs"]',
    delimiters: ['v{', '}'],
    data: {
      terms: [],
      posts: [],
      query: {
        page: parseInt(
          document.querySelector('[data-js="programs"]').dataset.jsPage
        ),
        per_page: 5
      },
      headers: {
        pages: 8,
        total: 40,
        link: 'rel="next";'
      },
      endpoints: {
        terms: '/wp-json/api/v1/terms',
        programs: '/wp-json/wp/v2/programs'
      },
      busy: true,
      init: false,
      abort: new AbortController,
      maps: function() {
        return {
          filters: (filter) => ({
            'name': filter.labels.archives,
            'slug': filter.name,
            'filters': filter.terms.map(f => ({
              'id': f.term_id,
              'name': f.name,
              'slug': f.slug,
              'parent': filter.name
            })),
            'STRINGS': {
              'ALL': window.LOCALIZED_STRINGS.find(e => e.slug === 'ALL').label || 'ALL'
            }
          }),
          programs: (p) => ({
            'title': p.acf.plain_language_program_name,
            'link': p.link,
            'subtitle': p.acf.program_name + ((p.acf.program_acronym) ?
              ' (' + p.acf.program_acronym + ')' : ''),
            'summary': p.acf.brief_excerpt,
            // Demonstration on how to add the cta link
            // 'cta': p.link + ((
            //     p.acf.show_sections &&
            //     p.acf.show_sections.find(s => s.value === 'how-to-apply').value
            //   ) ? '?step=how-to-apply' : ''),
            'category': {
              'slug': (p.terms && p.terms.find(t => t.taxonomy === 'programs').slug
                .replace(new RegExp(`\\-${this.lang.code}$`), '')) || 'PROGRAMS',
              'name': (p.terms && p.terms.find(t => t.taxonomy === 'programs').name) || 'NAME'
            },
            'STRINGS': {
              'LEARN_MORE': window.LOCALIZED_STRINGS.find(e => e.slug === 'LEARN_MORE').label || 'LEARN_MORE',
              'CTA': window.LOCALIZED_STRINGS.find(e => e.slug === 'APPLY').label || 'APPLY'
            }
          })
        }
      }
    },
    computed: {
      next: function() {
        return (this.query.page < this.headers.pages);
      },
      previous: function() {
        return (this.query.page > 1);
      },
      lang: () => {
        let lang = document.querySelector('html').lang;
        return (lang !== 'en') ? {
          code: lang,
          path: `/${lang}`
        } : {
          code: 'en',
          path: ''
        };
      }
    },
    methods: {
      fetch: function(data = false) {
        if (!data) return data;

        return (this[data].length) ? this[data] :
          fetch(this.lang.path + this.endpoints[data])
            .then(response => response.json())
            .then(d => {
              Vue.set(this, 'busy', false);
              Vue.set(this, data, d.map(this.maps().filters))
            });
      },
      click: function(event) {
        let taxonomy = event.data.parent;
        let term = event.data.id || false;

        if (term) {
          this.filter(taxonomy, term);
        } else {
          this.filterAll(taxonomy);
        }
      },
      filter: function(taxonomy, term) {
        let terms = (this.query.hasOwnProperty(taxonomy)) ?
          this.query[taxonomy] : [term]; // get other query or initialize.

        // Toggle, if the taxonomy exists, filter it out, otherwise add it.
        if (this.query.hasOwnProperty(taxonomy))
          terms = (terms.includes(term)) ?
            terms.filter(el => el !== term) : terms.concat([term]);

        this.filter(taxonomy, terms);
      },
      filterAll: function(taxonomy) {
        let tax = this.terms.find(t => t.slug === taxonomy);
        let checked = !(tax.checked);

        Vue.set(tax, 'checked', checked);

        let terms = tax.filters.map((term) => {
            Vue.set(term, 'checked', checked);
            return term.id;
          });

        this.filterSet(taxonomy, (checked) ? terms : []);
      },
      filterSet: function(taxonomy, terms) {
        return new Promise((resolve, reject) => {
          Vue.set(this.query, taxonomy, terms);
          Vue.set(this.query, 'page', 1);

          this.posts.map((value, index) => {
            if (value) Vue.set(this.posts[index], 'show', false);
            return value;
          });
          resolve();
        })
        .then(this.wp)
        .catch((message) => {
          // console.dir(message);
        });
      },
      reset: function(event) {
        return new Promise(resolve => {
          let taxonomy = event.data.slug;
          if (this.query.hasOwnProperty(taxonomy)) {
            Vue.set(this.query, taxonomy, []);
            resolve();
          }
        });
      },
      paginate: function(event) {
        event.preventDefault();

        // The change is the next page as well as an indication of what
        // direction we are moving in for the queue.
        let change = parseInt(event.target.dataset.amount);
        let page = this.query.page + change;

        return new Promise((resolve) => {
          Vue.set(this.query, 'page', page);
          Vue.set(this.posts[this.query.page], 'show', true);

          this.queue([0, change]);
          resolve();
        });
      },
      wp: function() {
        return this.queue();
      },
      queue: function(queries = [0, 1]) {
        // Set a benchmark query to compare the upcomming query to.
        let Obj1 = Object.assign({}, this.query); // create copy of object.
        delete Obj1.page; // delete the page attribute because this will always be different.
        Object.freeze(Obj1); // prevent changes to our comparison.

        // The function is async because we want to wait until each promise
        // is query is finished before we run the next. This is because we
        // don't want to bother sending a request if there are no previous or
        // next pages. The way we find out if there are previous or next pages
        // relative to the current page query is through the headers of the
        // response provided by the WP REST API.
        (async () => {
          for (let i = 0; i < queries.length; i++) {
            let query = Object.assign({}, this.query);
            let promise = new Promise(resolve => resolve());
            let link = this.headers.link;
            let pages = this.headers.pages;
            let page = this.query.page;
            let current = false;
            let next = false;
            let previous = false;

            // Build the query and set its page number.
            Object.defineProperty(query, 'page', {
              value: page + queries[i],
              enumerable: true
            });

            // There will never be a page 0 or below, so skip this query.
            if (query.page <= 0) continue;

            // Check to see if we have the page that we are going to queued
            // and the query structure of that page matches the current query
            // structure (other than the page, which will obviously be different).
            // This will help us determine if we need to make a new request.
            let havePage = (this.posts[query.page]) ? true : false;
            let pageQueryMatches = false;

            if (havePage) {
              let Obj2 = Object.assign({}, this.posts[query.page].query);
              delete Obj2.page;
              pageQueryMatches = Object.isEqual(Obj1, Obj2);
            }

            if (havePage && pageQueryMatches) continue;

            // If this is the current page we want the query to go through.
            current = (query.page === page);

            // If there is a next or previous page, we'll prefetch them.
            // We'll know there's a next or previous page based on the
            // headers sent by the current page query.
            next = (page < pages && query.page > page);
            previous = (page > 1 && query.page < page);

            if (current || next || previous)
              await promise.then(() => {
                return this.wpQuery(query);
              })
              .then(this.response)
              .then((data) => {
                let headers = Object.assign({}, this.headers);
                this.process(data, query, headers);
              }).catch(this.error);
          }
        })();
      },
      wpQuery: function(query) {
        Vue.set(this, 'busy', true);

        Vue.set(this, 'abort', (new AbortController));
        let signal = this.abort.signal;
        let url = `${this.lang.path}${this.endpoints.programs}`;

        // Build the url query.
        url = `${url}?` + Object.keys(query)
          .map(k => {
            if (Array.isArray(query[k]))
              return query[k].map(a => `${k}[]=${a}`).join('&');
            return `${k}=${query[k]}`;
          }).join('&');

        // Set posts and store a copy of the query for reference.
        Vue.set(this.posts, query.page, {
          posts: [],
          query: Object.freeze(query),
          show: (this.query.page >= query.page)
        });

        return fetch(url, {signal: signal});
      },
      response: function(response) {
        let headers = {
          total: 'X-WP-Total',
          pages: 'X-WP-TotalPages',
          link: 'Link'
        };

        if (response.ok) {
          let keys = Object.keys(headers);

          for (let i = 0; i < keys.length; i++) {
            let header = response.headers.get(headers[keys[i]]);
            let value = (isNaN(header)) ? header : (parseInt(header) || 0);
            headers[keys[i]] = value;
          }

          Vue.set(this, 'headers', headers);
        }

        return response.json();
      },
      process: function(data, query, headers) {
        // If there are posts for this query, map them to the template.
        let posts = (Array.isArray(data)) ?
          data.map(this.maps().programs) : false;

        // Set posts and store a copy of the query for reference.
        Vue.set(this.posts[query.page], 'posts', posts);
        Vue.set(this.posts[query.page], 'headers', Object.freeze(headers));

        // If there are no posts, pass along to the error handler.
        if (!Array.isArray(data))
          this.error({error: data, query: query});

        Vue.set(this, 'busy', false);
        Vue.set(this, 'init', true);
      },
      error: function(response) {
        // If there are no posts for the current page, requeue from the first page.
        // let noPosts = (response.error.code === 'rest_post_invalid_page_number');
        // let forCurrentPage = (response.query.page === this.query.page);

        // if (noPosts && forCurrentPage) {
        //   Vue.set(this.query, 'page', 1);
        //   this.wp();
        // }
        console.dir(response);
        Vue.set(this, 'busy', false);
      }
    },
    created: function() {
      this.queue();

      this.fetch('terms')
        .catch(this.error);
    }
  });
</script>
{% endblock %}
